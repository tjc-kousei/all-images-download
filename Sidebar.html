<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>画像一括ダウンロードツール</title>
  <!-- JSZip（CDN） -->
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
  <style>
    *{box-sizing:border-box}
    body{font:13px/1.6 system-ui,-apple-system,Segoe UI,Roboto,sans-serif;margin:0;padding:12px}
    h3{margin:0 0 8px}
    label{display:block;margin:8px 0 4px}
    input[type=text],input[type=number],select{width:100%;padding:8px;min-width:0}
    button{padding:10px 12px;width:100%}
    .muted{color:#666;font-size:12px}
    .ok{color:#0a8;margin-top:8px}
    .err{color:#d33;margin-top:8px;white-space:pre-line}
    progress{width:100%;height:16px}
    .small{font-size:12px}
    .section{margin-top:12px}

    /* レスポンシブ配置 */
    .grid-2{display:grid;grid-template-columns:1fr;gap:8px}
    .grid-3{display:grid;grid-template-columns:1fr;gap:8px}
    @media(min-width:520px){.grid-2{grid-template-columns:1fr 1fr}}
    @media(min-width:680px){.grid-3{grid-template-columns:1fr 1fr 1fr}}

    /* プレビュー */
    .previewWrap{margin-top:12px}
    .previewHead{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    .badge{display:inline-block;padding:2px 6px;font-size:11px;background:#eee;border-radius:4px}
    .pvControls{display:grid;grid-template-columns:1fr 120px;gap:8px;align-items:center}
    .pvMode{display:flex;gap:6px;flex-wrap:wrap}
    .pvBox{border:1px solid #ddd;background:#fff;padding:4px}
    .pvSideBySide{display:grid;grid-template-columns:1fr;gap:8px}
    @media(min-width:480px){.pvSideBySide{grid-template-columns:1fr 1fr}}
    canvas{max-width:100%;height:auto;display:block}

    /* 比較スライダー */
    .cmpWrap{position:relative;width:100%;background:#fff;border:1px solid #ddd}
    .cmpBase{display:block;width:100%}
    .cmpMask{position:absolute;left:0;top:0;bottom:0;overflow:hidden;border-right:2px solid #fff}
    .cmpTop{display:block}
    .cmpHandle{position:absolute;top:0;bottom:0;width:2px;background:#0aa;box-shadow:0 0 0 1px #0aa}
    .cmpBar{width:100%}

    /* ズームビュー（等倍） */
    .zoomBox{position:relative;border:1px solid #ddd;background:#fff;touch-action:none}
    .zoomHint{position:absolute;right:6px;bottom:6px;background:#0008;color:#fff;font-size:11px;padding:2px 6px;border-radius:4px}

    /* details/summary（オプション折りたたみ） */
    details{border:1px solid #e5e5e5;border-radius:6px;padding:8px 10px;background:#fafafa}
    details>summary{cursor:pointer;list-style:none}
    details>summary::-webkit-details-marker{display:none}
    .sumRow{display:flex;align-items:center;gap:8px}
    .sumRow .pill{background:#eef8f7;color:#066;padding:2px 6px;border-radius:999px;font-size:11px}
  </style>
</head>
<body>
  <h3>画像一括ダウンロードツール</h3>

  <form id="f">
    <div class="section">
      <label>キーワード</label>
      <input type="text" name="keyword" placeholder="例: tech" required>

      <label>公開日 (YYYYMMDD)</label>
      <input type="text" name="date" placeholder="例: 20250823" pattern="[0-9]{8}" inputmode="numeric" maxlength="8" autocomplete="off" required>
    </div>

    <!-- 基本設定（シンプル） -->
    <div class="section grid-2">
      <div>
        <label>リサイズ</label>
        <select name="resizeMode">
          <option value="width">幅指定（px）</option>
          <option value="none">リサイズしない</option>
        </select>
      </div>
      <div id="widthRow">
        <label>出力幅 (px)</label>
        <input type="number" name="targetW" min="64" step="1" value="768">
      </div>
    </div>

    <!-- 詳細オプション（折りたたみ） -->
    <div class="section">
      <details id="adv">
        <summary>
          <div class="sumRow">
            <strong>詳細オプション</strong>
            <span class="pill" id="advSummary">既定</span>
          </div>
          <div class="muted">必要な場合のみ開いて調整してください</div>
        </summary>
        <div class="section grid-2">
          <div>
            <label>JPEG品質 (0.80–1.00)</label>
            <input type="number" name="quality" min="0.8" max="1.0" step="0.01" value="0.95">
          </div>
          <div>
            <label>シャープ補正 a (0–1)</label>
            <input type="number" name="sharpen" min="0" max="1" step="0.05" value="0.15">
          </div>
        </div>
        <div class="grid-3 section">
          <div>
            <label>ノイズ低減（事前ぼかし）(0–2px)</label>
            <input type="number" name="denoise" min="0" max="2" step="0.1" value="0">
          </div>
          <div>
            <label>リサンプル方法</label>
            <select name="resample">
              <option value="auto">Auto（ブラウザ高品質）</option>
              <option value="progressive">段階縮小（強い縮小に有効）</option>
            </select>
          </div>
          <div>
            <label>プレビュー比較モード</label>
            <select id="modeSelect">
              <option value="side">並べて比較</option>
              <option value="slider">比較スライダー</option>
              <option value="zoom">等倍(1:1)ズーム</option>
            </select>
          </div>
        </div>
      </details>
    </div>

    <div class="muted">出力例: <code>img-keyword-YYYYMMDD-01.jpg</code>（拡張子は .jpg）</div>

    <div class="section"><button type="submit">一括エクスポート（ZIPを保存）</button></div>
  </form>

  <!-- プレビュー -->
  <div class="previewWrap">
    <div class="previewHead">
      <strong>プレビュー</strong>
      <span class="badge" id="pvMeta">未読込</span>
      <div style="flex:1 0 140px">
        <div class="pvControls">
          <input type="range" id="pvIndex" min="1" max="1" value="1">
          <div class="muted" style="text-align:right"><span id="pvIndexLabel">1 / 1</span></div>
        </div>
      </div>
      <div style="display:flex;gap:6px;width:100%">
        <button id="btnPrev" type="button" style="flex:1">◀ 前へ</button>
        <button id="btnLoadPrev" type="button" style="flex:1">プレビュー読み込み</button>
        <button id="btnNext" type="button" style="flex:1">次へ ▶</button>
      </div>
    </div>

    <!-- サイドバイサイド -->
    <div class="pvSideBySide section" id="modeSide">
      <div class="pvBox"><div class="muted">原画像（表示用に縮小）</div><canvas id="pvSrc"></canvas></div>
      <div class="pvBox"><div class="muted">出力プレビュー</div><canvas id="pvDst"></canvas></div>
    </div>

    <!-- 比較スライダー -->
    <div class="section" id="modeSlider" style="display:none">
      <div class="cmpWrap" id="cmpWrap">
        <canvas id="cmpBase" class="cmpBase"></canvas>
        <div id="cmpMask" class="cmpMask" style="width:50%">
          <canvas id="cmpTop" class="cmpTop"></canvas>
        </div>
        <div id="cmpHandle" class="cmpHandle" style="left:50%"></div>
      </div>
      <input id="cmpRange" class="cmpBar" type="range" min="0" max="100" value="50">
      <div class="muted">左：原画像 / 右：出力（バーを動かして比較）</div>
    </div>

    <!-- ズームモード -->
    <div class="section" id="modeZoom" style="display:none">
      <div class="zoomBox" id="zoomBox" style="width:100%">
        <canvas id="zoomCanvas"></canvas>
        <div class="zoomHint">ドラッグで移動 / ホイールで拡大縮小</div>
      </div>
      <div class="muted">表示は出力画像です（品質はそのまま）。</div>
    </div>
  </div>

  <div id="status" class="small section"></div>
  <progress id="bar" max="100" value="0" style="display:none"></progress>
  <div id="out" class="section"></div>

<script>
const $ = s => document.querySelector(s);
const sleep = ms => new Promise(r => setTimeout(r, ms));
const debounce = (fn, d=150) => { let t; return (...a)=>{ clearTimeout(t); t=setTimeout(()=>fn(...a), d); } };

// 公開日 正規化（全角→半角、数字以外除去、8桁）
const dateI = document.querySelector('input[name="date"]');
dateI.addEventListener('input', e => {
  let v = e.target.value;
  v = v.replace(/[０-９]/g, ch => String.fromCharCode(ch.charCodeAt(0) - 0xFEE0));
  v = v.replace(/[^0-9]/g, '').slice(0, 8);
  e.target.value = v;
});

// リサイズモードで幅入力の有効/無効切替
const resizeSelect = document.querySelector('select[name="resizeMode"]');
const widthRow = $('#widthRow');
function updateWidthRow(){ widthRow.style.display = resizeSelect.value === 'none' ? 'none' : ''; }
resizeSelect.addEventListener('change', updateWidthRow); updateWidthRow();

// 詳細オプションの要約（summary）表示を更新
const adv = $('#adv');
const advSummary = $('#advSummary');
function refreshAdvSummary(){
  const q = Number(document.querySelector('[name="quality"]').value);
  const s = Number(document.querySelector('[name="sharpen"]').value);
  const d = Number(document.querySelector('[name="denoise"]').value);
  const r = document.querySelector('[name="resample"]').value;
  const parts = [];
  if (q !== 0.95) parts.push(`Q:${q.toFixed(2)}`);
  if (s !== 0.15) parts.push(`S:${s}`);
  if (d !== 0) parts.push(`D:${d}`);
  if (r !== 'auto') parts.push(`R:${r}`);
  advSummary.textContent = parts.length ? parts.join(' / ') : '既定';
}
adv.addEventListener('toggle', refreshAdvSummary);
['quality','sharpen','denoise','resample'].forEach(n=>document.querySelector(`[name="${n}"]`).addEventListener('input', debounce(refreshAdvSummary,150)));
refreshAdvSummary();

// —— 一括エクスポート —— //
$('#f').addEventListener('submit', async (e) => {
  e.preventDefault();
  $('#out').innerHTML=''; $('#status').textContent=''; $('#bar').style.display='block'; $('#bar').value=0;
  const btn = $('#f button[type="submit"]'); btn.disabled=true; btn.textContent='処理中…';
  try {
    const o = readOptions();
    if (!o.keyword || !/^[0-9]{8}$/.test(o.date)) throw new Error('キーワードと公開日(YYYYMMDD)を正しく入力してください。');

    const total = await call('countImages');
    if (!total){ $('#status').textContent='画像が見つかりませんでした。'; return; }

    const batchSize = 8; const zip = new JSZip(); let processed=0, seq=1;
    for (let offset=0; offset<total; offset+=batchSize){
      const pack = await call('getImagesBatch', offset, batchSize);
      for (const it of pack.items){
        const nn = String(seq++).padStart(2,'0');
        const fname = `img-${o.keyword}-${o.date}-${nn}.jpg`;
        const blob = await convertWithOptions(it.b64, it.mime, o);
        zip.file(fname, blob);
        processed++; $('#status').textContent=`処理中… ${processed} / ${total}`; $('#bar').value = Math.round((processed/total)*100);
        await sleep(5);
      }
    }
    const zipName = `img-${o.keyword}-${o.date}.zip`;
    const zipBlob = await zip.generateAsync({type:'blob'});
    const url = URL.createObjectURL(zipBlob); const a = document.createElement('a'); a.href=url; a.download=zipName; a.click(); setTimeout(()=>URL.revokeObjectURL(url),60000);
    $('#out').innerHTML = `<div class="ok">完了：${processed}件の画像をZIPにまとめました（${zipName}）。</div>`;
  } catch(err){
    $('#out').innerHTML = `<div class="err">エラー: ${err && err.message ? err.message : err}</div>`;
  } finally { btn.disabled=false; btn.textContent='一括エクスポート（ZIPを保存）'; $('#bar').style.display='none'; }
});

function readOptions(){
  const form = Object.fromEntries(new FormData($('#f')).entries());
  let keyword = (form.keyword||'').trim();
  // ファイル名に使えない文字の置換（バックスラッシュは除外して複雑なエスケープを回避）
  keyword = keyword.replace(/[/:*?"<>|]/g,'-').replaceAll(' ','-').replaceAll('　','-');
  const date = (form.date||'').trim();
  const quality = Math.min(1, Math.max(0.8, Number(form.quality||0.95)));
  const sharpen = Math.min(1, Math.max(0, Number(form.sharpen||0.15)));
  const denoise = Math.min(2, Math.max(0, Number(form.denoise||0)));
  const resample = form.resample||'auto';
  const resizeMode = form.resizeMode||'width';
  const targetW = Math.max(1, Number(form.targetW||768))|0;
  return {keyword,date,quality,sharpen,denoise,resample,resizeMode,targetW};
}

async function call(fn, ...args){
  return await new Promise((res,rej)=>{ google.script.run.withSuccessHandler(res).withFailureHandler(rej)[fn](...args); });
}

// —— プレビュー —— //
let pvTotal=0; let pvCache={}; // index -> {mime,b64,img}
let outCache=new Map(); // key -> Blob
const optKey = (o)=>JSON.stringify({q:o.quality,s:o.sharpen,d:o.denoise,r:o.resample,m:o.resizeMode,w:o.targetW});

$('#btnLoadPrev').addEventListener('click', async ()=>{
  pvTotal = await call('countImages'); if (!pvTotal){ $('#pvMeta').textContent='画像なし'; return; }
  $('#pvIndex').max = pvTotal; $('#pvIndex').value = 1; $('#pvIndexLabel').textContent = `1 / ${pvTotal}`; $('#pvMeta').textContent = `全${pvTotal}枚`;
  await renderAllModes(1);
});
$('#btnPrev').addEventListener('click', ()=>{ const cur=Number($('#pvIndex').value); if(cur>1){ $('#pvIndex').value=cur-1; $('#pvIndex').dispatchEvent(new Event('input')); }});
$('#btnNext').addEventListener('click', ()=>{ const cur=Number($('#pvIndex').value); if(cur<pvTotal){ $('#pvIndex').value=cur+1; $('#pvIndex').dispatchEvent(new Event('input')); }});

document.addEventListener('keydown', (e)=>{ if(e.key==='ArrowLeft') $('#btnPrev').click(); else if(e.key==='ArrowRight') $('#btnNext').click(); });

$('#pvIndex').addEventListener('input', async (e)=>{ const idx=Number(e.target.value); $('#pvIndexLabel').textContent=`${idx} / ${pvTotal}`; await renderAllModes(idx); });

// モード切替（詳細セクションのセレクタと連動）
const modeSelect = $('#modeSelect');
modeSelect.addEventListener('change', ()=>{
  const mode = modeSelect.value;
  $('#modeSide').style.display = mode==='side' ? '' : 'none';
  $('#modeSlider').style.display = mode==='slider' ? '' : 'none';
  $('#modeZoom').style.display = mode==='zoom' ? '' : 'none';
  document.getElementById('zoomRow').style.display = mode==='zoom' ? '' : 'none';
});

// オプション変更で自動再描画（デバウンス）
;['quality','sharpen','denoise','resample','resizeMode','targetW'].forEach(n=>{
  document.querySelector(`[name="${n}"]`).addEventListener('input', debounce(()=>{
    if(pvTotal>0){ const idx=Number($('#pvIndex').value||1); renderAllModes(idx,true); refreshAdvSummary(); }
  }, 200));
});

async function renderAllModes(idx, bust=false){
  const {mime,b64,img} = await ensurePreviewImage(idx);
  // サイドバイサイド
  await drawToCanvasFit($('#pvSrc'), img, 600);
  const outImg = await getOutputImage(idx, mime, b64, bust);
  await drawToCanvasFit($('#pvDst'), outImg, 600);

  // 比較スライダー
  await drawCompare(img, outImg);

  // ズーム
  setupZoom(outImg);
}

async function ensurePreviewImage(idx){
  if(pvCache[idx]) return pvCache[idx];
  const pack = await call('getImagesBatch', idx-1, 1);
  const it = pack.items[0];
  const img = await loadImage(`data:${it.mime};base64,${it.b64}`);
  return (pvCache[idx] = {mime:it.mime,b64:it.b64,img});
}

async function getOutputImage(idx, mime, b64, bust=false){
  const o=readOptions(); const key = idx+'|'+optKey(o);
  if(!bust && outCache.has(key)) return await blobToImage(outCache.get(key));
  const blob = await convertWithOptions(b64, mime, o);
  outCache.set(key, blob);
  return await blobToImage(blob);
}

async function drawToCanvasFit(canvas, img, fitW=600){
  const scale = Math.min(1, fitW/img.naturalWidth);
  const w = Math.max(1, Math.round(img.naturalWidth*scale));
  const h = Math.max(1, Math.round(img.naturalHeight*scale));
  canvas.width=w; canvas.height=h; const ctx=canvas.getContext('2d');
  ctx.imageSmoothingEnabled=true; ctx.imageSmoothingQuality='high';
  ctx.clearRect(0,0,w,h); ctx.drawImage(img,0,0,w,h);
}

// 比較スライダー描画
async function drawCompare(srcImg, outImg){
  const base = $('#cmpBase'); const top = $('#cmpTop'); const wrap=$('#cmpWrap'); const mask=$('#cmpMask'); const handle=$('#cmpHandle');
  const dispW = wrap.clientWidth || 600; const scale = Math.min(1, dispW/srcImg.naturalWidth);
  const w = Math.max(1, Math.round(srcImg.naturalWidth*scale));
  const h = Math.max(1, Math.round(srcImg.naturalHeight*scale));
  [base, top].forEach(c=>{ c.width=w; c.height=h; });
  const bctx = base.getContext('2d'); const tctx = top.getContext('2d');
  bctx.imageSmoothingEnabled=true; bctx.imageSmoothingQuality='high'; bctx.clearRect(0,0,w,h); bctx.drawImage(srcImg,0,0,w,h);
  tctx.imageSmoothingEnabled=true; tctx.imageSmoothingQuality='high'; tctx.clearRect(0,0,w,h); tctx.drawImage(outImg,0,0,w,h);

  const range=$('#cmpRange'); const pct=range.value|0; mask.style.width=pct+'%'; handle.style.left=pct+'%';
  // ドラッグ操作
  const setPct=(p)=>{ const clamped=Math.max(0,Math.min(100,p)); range.value=clamped; mask.style.width=clamped+'%'; handle.style.left=clamped+'%'; };
  let dragging=false; const onMove=(e)=>{ if(!dragging) return; const rect=wrap.getBoundingClientRect(); const p=( (e.touches? e.touches[0].clientX:e.clientX)-rect.left)/rect.width*100; setPct(p); };
  handle.onmousedown=()=>dragging=true; handle.ontouchstart=()=>dragging=true; window.addEventListener('mousemove',onMove); window.addEventListener('touchmove',onMove,{passive:false}); window.addEventListener('mouseup',()=>dragging=false); window.addEventListener('touchend',()=>dragging=false);
  range.oninput=(e)=>setPct(e.target.value);
}

// ズームビュー
let zoomState={scale:1, ox:0, oy:0, img:null};
function setupZoom(img){
  const box=$('#zoomBox'); const cvs=$('#zoomCanvas'); const ctx=cvs.getContext('2d');
  zoomState.img=img; zoomState.scale=($('#zoom').value|0)/100; zoomState.ox=0; zoomState.oy=0;
  const fitW = box.clientWidth||600; const w=Math.round(img.naturalWidth*zoomState.scale), h=Math.round(img.naturalHeight*zoomState.scale);
  cvs.width=Math.max(50, Math.min(fitW, w)); cvs.height=Math.max(50, Math.min(Math.round(fitW*0.6), h));
  const draw=()=>{ ctx.clearRect(0,0,cvs.width,cvs.height); ctx.imageSmoothingEnabled=true; ctx.imageSmoothingQuality='high'; ctx.drawImage(img, zoomState.ox, zoomState.oy, cvs.width/zoomState.scale, cvs.height/zoomState.scale, 0,0,cvs.width,cvs.height); };
  draw();

  // ドラッグでパン
  let dragging=false, sx=0, sy=0, sox=0, soy=0;
  const start=(x,y)=>{dragging=true; sx=x; sy=y; sox=zoomState.ox; soy=zoomState.oy};
  const move=(x,y)=>{ if(!dragging) return; const dx=(x-sx)/zoomState.scale; const dy=(y-sy)/zoomState.scale; zoomState.ox=sox-dx; zoomState.oy=soy-dy; draw(); };
  const end=()=>dragging=false;
  cvs.onmousedown=e=>start(e.offsetX,e.offsetY);
  cvs.onmousemove=e=>move(e.offsetX,e.offsetY);
  cvs.onmouseup=end; cvs.onmouseleave=end;
  cvs.ontouchstart=e=>{ const t=e.touches[0]; const r=cvs.getBoundingClientRect(); start(t.clientX-r.left,t.clientY-r.top); };
  cvs.ontouchmove=e=>{ const t=e.touches[0]; const r=cvs.getBoundingClientRect(); move(t.clientX-r.left,t.clientY-r.top); e.preventDefault(); };
  cvs.ontouchend=end;

  // ホイールでズーム
  $('#zoom').oninput=(e)=>{ $('#zoomLabel').textContent=e.target.value+'%'; zoomState.scale=(e.target.value|0)/100; draw(); };
  cvs.onwheel=(e)=>{ e.preventDefault(); let v=$('#zoom').value|0; v+= (e.deltaY<0? 10:-10); v=Math.max(50,Math.min(300,v)); $('#zoom').value=v; $('#zoom').dispatchEvent(new Event('input')); };
}

// 画像読み込み等
function loadImage(src){ return new Promise((resolve,reject)=>{ const img=new Image(); img.onload=()=>resolve(img); img.onerror=reject; img.src=src; }); }
function blobToImage(blob){ return new Promise((resolve,reject)=>{ const url=URL.createObjectURL(blob); const img=new Image(); img.onload=()=>{URL.revokeObjectURL(url); resolve(img)}; img.onerror=(e)=>{URL.revokeObjectURL(url); reject(e)}; img.src=url; }); }
function canvasToBlob(canvas, type, quality){ return new Promise((resolve)=>{ canvas.toBlob((blob)=>resolve(blob), type, quality); }); }

// 変換本体
async function convertWithOptions(b64, mime, opt){
  const img = await loadImage(`data:${mime};base64,${b64}`);
  const src = document.createElement('canvas'); src.width=img.naturalWidth; src.height=img.naturalHeight; const sctx=src.getContext('2d');
  sctx.clearRect(0,0,src.width,src.height); if(opt.denoise>0) sctx.filter=`blur(${opt.denoise}px)`; sctx.fillStyle='#ffffff'; sctx.fillRect(0,0,src.width,src.height); sctx.drawImage(img,0,0,src.width,src.height); sctx.filter='none';
  let targetW, targetH; if(opt.resizeMode==='none'){ targetW=src.width; targetH=src.height; } else { targetW=opt.targetW|0; const scale=targetW/src.width; targetH=Math.max(1,Math.round(src.height*scale)); }
  let resized = await resizeCanvas(src, targetW, targetH, opt.resample);
  if(opt.sharpen>0) applySharpen(resized.getContext('2d'), resized.width, resized.height, opt.sharpen);
  const blob = await canvasToBlob(resized, 'image/jpeg', opt.quality); return blob;
}

async function resizeCanvas(srcCanvas, targetW, targetH, method='auto'){
  if(method==='progressive' && (targetW < srcCanvas.width || targetH < srcCanvas.height)){
    let cur=srcCanvas; while(cur.width*0.5>targetW){ const step=document.createElement('canvas'); step.width=Math.max(1,Math.round(cur.width*0.5)); step.height=Math.max(1,Math.round(cur.height*0.5)); const ctx=step.getContext('2d'); ctx.imageSmoothingEnabled=true; ctx.imageSmoothingQuality='high'; ctx.fillStyle='#ffffff'; ctx.fillRect(0,0,step.width,step.height); ctx.drawImage(cur,0,0,step.width,step.height); cur=step; }
    const dst=document.createElement('canvas'); dst.width=targetW; dst.height=targetH; const dctx=dst.getContext('2d'); dctx.imageSmoothingEnabled=true; dctx.imageSmoothingQuality='high'; dctx.fillStyle='#ffffff'; dctx.fillRect(0,0,dst.width,dst.height); dctx.drawImage(cur,0,0,dst.width,dst.height); return dst;
  } else {
    const dst=document.createElement('canvas'); dst.width=targetW; dst.height=targetH; const ctx=dst.getContext('2d'); ctx.imageSmoothingEnabled=true; ctx.imageSmoothingQuality='high'; ctx.fillStyle='#ffffff'; ctx.fillRect(0,0,dst.width,dst.height); ctx.drawImage(srcCanvas,0,0,dst.width,dst.height); return dst;
  }
}

// 修正版シャープ
function applySharpen(ctx,w,h,a){
  a=Math.max(0,Math.min(1,a)); const src=ctx.getImageData(0,0,w,h); const dst=ctx.createImageData(w,h); const sp=src.data, dp=dst.data; const center=1+4*a, side=-a; const clamp=v=>v<0?0:v>255?255:v; const idx=(x,y,c)=>((y*w+x)<<2)+c;
  // 辺は原画
  for(let x=0;x<w;x++){ for(let c=0;c<4;c++){ dp[idx(x,0,c)]=sp[idx(x,0,c)]; dp[idx(x,h-1,c)]=sp[idx(x,h-1,c)]; } }
  for(let y=0;y<h;y++){ for(let c=0;c<4;c++){ dp[idx(0,y,c)]=sp[idx(0,y,c)]; dp[idx(w-1,y,c)]=sp[idx(w-1,y,c)]; } }
  for(let y=1;y<h-1;y++){
    for(let x=1;x<w-1;x++){
      for(let c=0;c<3;c++){
        const v = sp[idx(x,y,c)]*center + sp[idx(x-1,y,c)]*side + sp[idx(x+1,y,c)]*side + sp[idx(x,y-1,c)]*side + sp[idx(x,y+1,c)]*side;
        dp[idx(x,y,c)] = clamp(v);
      }
      dp[idx(x,y,3)] = 255;
    }
  }
  ctx.putImageData(dst,0,0);
}
</script>
</body>
</html>
